# -*- coding: utf-8 -*-
"""Inventory_new.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ky5z9muom8uZna5U9bG87vMjSJCw1vmP
"""

from math import sqrt, ceil
from collections import defaultdict

demandList = [81, 67, 53, 96, 35, 65, 27, 81, 84, 32, 50, 47, 7, 88, 20, 25, 88, 74, 62, 52, 77, 96, 64, 87, 51, 7, 85, 82, 53, 96]
holdingCost = 1
orderCost = 100
rolling = 10

def PeriodicOrderInterval(demands):
  demandCount = len(demands)
  totalDemand = sum(demands)
  economicOrderInterval = ceil(sqrt(2 * orderCost / (holdingCost * totalDemand / demandCount)))
  return economicOrderInterval

def SilverMealInterval(demands):
  demandCount = len(demands)
  incrementalHoldingCost = []
  costByPeriod = []
  for period in range(demandCount):
    incrementalHoldingCost.append(holdingCost * period * demands[period])
    cumulativeHoldingCost = sum(incrementalHoldingCost)
    totalRelevantCost = orderCost + cumulativeHoldingCost
    costByPeriod.append(totalRelevantCost / (period + 1))
    if period != 0 and costByPeriod[period] > costByPeriod[period - 1]:
      return period
  return demandCount

def LeastUnitInterval(demands):
  demandCount = len(demands)
  incrementalHoldingCost = []
  costByPeriod = []
  for period in range(demandCount):
    cumulativeDemand = sum(demands[:period+1])
    incrementalHoldingCost.append(holdingCost * period * demands[period])
    cumulativeHoldingCost = sum(incrementalHoldingCost)
    totalRelevantCost = orderCost + cumulativeHoldingCost
    costByPeriod.append(totalRelevantCost / cumulativeDemand)
    if period != 0 and costByPeriod[period] > costByPeriod[period - 1]:
      return period
  return demandCount

def PartPeriodInterval(demands):
  demandCount = len(demands)
  economicPartPeriod = orderCost / holdingCost
  partPeriodCosts = []
  for period in range(demandCount):
    partPeriodCosts.append(period * demands[period])
    if sum(partPeriodCosts) >= economicPartPeriod:
      return period
  return demandCount

def CostCalculation(demands, intervalFunction, updateInterval=True):
  demandCount = len(demands)
  period = 0
  lotSize = [0 for _ in range(demandCount)]
  if not updateInterval: interval = intervalFunction(demands)
  while period < demandCount:
    if updateInterval: interval = intervalFunction(demands[period:])
    for i in range(interval):
      lotSize[period] += demands[period+i]
      
    period += interval
   
  inventory = [0 for _ in range(demandCount)]
  currentItem = 0
  for period in range(demandCount):
    currentItem += lotSize[period] # Order
    currentItem -= demands[period] # Demand
    inventory[period] = currentItem
  
  orderCount = len([order for order in lotSize if order != 0])
  totalCost = holdingCost*sum(inventory) + orderCost*orderCount
  return {
      'Cost': totalCost,
      'LotSize': lotSize,
      'Inventory': inventory
  }

periodRange = []
intervalFunctions = {
    'PeriodicOrder': PeriodicOrderInterval,
    'SilverMeal': SilverMealInterval,
    'LeastUnit': LeastUnitInterval,
    'PartPeriod': PartPeriodInterval,
}
costs = defaultdict(list)
inventories = defaultdict(list)
lotsizes = defaultdict(list)

def calculateForRange(startPeriod, endPeriod):
  periodRange.append((startPeriod+1, endPeriod+1))
  for name in intervalFunctions.keys():
    calculations = CostCalculation(demandList[startPeriod:endPeriod],
                                   intervalFunctions[name],
                                   updateInterval=False if name in ['PeriodicOrder'] else True)
    costs[name].append(calculations['Cost'])
    inventories[name].append(calculations['LotSize'])
    lotsizes[name].append(calculations['Inventory'])

for i in range(rolling):
  totalDemandCount = len(demandList) - rolling
  startPeriod = i
  endPeriod = i + totalDemandCount
  calculateForRange(startPeriod, endPeriod)

calculateForRange(0, 30)

import pandas as pd
from IPython.display import display
pd.DataFrame(data=costs, index=periodRange)

for name in intervalFunctions.keys():
  print('\t\t\t\t', name, 'Inventory')
  display(pd.DataFrame(data=lotsizes[name][:rolling], index=periodRange[:rolling]))
  print('='*100)
  print('\t\t\t\t', name, 'Order Lot Size Each Period')
  display(pd.DataFrame(data=inventories[name][:rolling], index=periodRange[:rolling]))
  print('='*100)

R10 = [81, 67, 53, 96, 35, 65, 27, 81, 84, 32]
R20 = [50, 47, 7, 88, 20, 25, 88, 74, 62, 52]
R30 = [77, 96, 64, 87, 51, 7, 85, 82, 53, 96]
CostCalculation(R10, SilverMealInterval, updateInterval=True )

CostCalculation(R20, SilverMealInterval, updateInterval=True )

CostCalculation(R30, SilverMealInterval, updateInterval=True )

"""Wagner within ile karşılaştırılmaası için kpnulan silver meal sonucu"""